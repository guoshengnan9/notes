## js运算精度问题
### 1、浮点数运算精度问题
JavaScript 使用 IEEE 754 标准中的双精度浮点数格式（64 位），用于表示和处理数字。然而，这种浮点数表示方法是基于二进制的，而不是十进制。
在二进制表示中，有些小数无法准确地表示为有限的二进制小数，就像在十进制中无法准确地表示 1/3 一样。例如，0.1（十进制）在二进制中是一个无限循环小数 0.00011001100110011...，
例如：let x = 0.1 + 0.2;
      console.log(x); // 输出：0.30000000000000004
当进行浮点数运算时，例如 0.2 + 0.1，JavaScript 引擎在内部会将这些数字转换为二进制进行计算。由于浮点数的精度有限，计算结果可能会有舍入误差。      
对于浮点数的精度误差有3种解决方案：
a、对于精度要求不高的可以使用toFixed(小数的位数)函数，将数值四舍五入到指定的位数
b、将小数乘以10^n,转化成整数之后进行加减运算，得到运算结果之后在除以10^n得到相应的小数相加的结果。
c、通过引入一些高精度运算的库，例如：BigNumber.js。
### 2、js中小数点后超出15位之后也会造成精度丢失。
在 JavaScript 中，浮点数的精度限制是由 IEEE 754 双精度浮点数表示法决定的，它使用 64 位来表示一个浮点数，浮点数在 JavaScript 中以二进制形式存储，
并且只能精确地表示有限数量的小数位数。当小数位数超过一定限制时（15位），就会出现精度丢失。
为了避免精度丢失，可以使用整数计算、高精度计算库（如 BigNumber.js 或 Decimal.js）等方法来处理浮点数计算。
### 3、整数运算超出范围
js 中不区分 int、float 等等，只有一个 Number 类型（即浮点类型）。占 64 位（8 字节），可以通过Number 对象的属性 Number.MAX_VALUE , Number.MIN_VALUE 来查看,
JavaScript 中 Number 范围为正负 2 的 53 次方，也即从最小值-9007199254740992 到最大值+9007199254740992 之间的范围,超出这个范围之后精度就会丢失。（最大值是16位）
为了避免精度丢失，可以使用整数计算、高精度计算库（如 BigNumber.js 或big.js）等方法来处理。
### 4、字符串转换成数字
在将字符串转换为数字时，JavaScript 会尽可能地解析字符串中的数字部分。然而，如果字符串表示的数字超出了 JavaScript 数字类型的范围，精度就会丢失。
例如：let x = parseInt("9007199254740993");
      console.log(x); // 输出：9007199254740992
      
bignumber.js和big.js技术选型：
相同点：BigNumber.js 和 Big.js 都是 JavaScript 中的第三方库，用于处理高精度的数值计算。它们的目标是提供可靠和准确的数值计算，解决 JavaScript 原生数值类型的精度限制。
不同点：a、库的大小和依赖：BigNumber.js 的文件大小较大，约为 30KB（压缩后），它没有任何外部依赖。而 Big.js 的文件大小较小，约为 3KB（压缩后），同        样也没有外部依赖。
       b、Big.js的社区活跃度没有BigNumber.js高。如果出现问题可能需要很久才能修复。